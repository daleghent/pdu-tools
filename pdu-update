#!/opt/local/bin/perl

use strict;
use warnings;

use URI;
use Getopt::Std;
use Net::OpenSSH;
use Net::Telnet;
use Net::FTP;
use File::Temp;
use Data::Validate::IP;
use Socket;

use vars qw/ %opt /;

my $opts = 'chu:U:P:';
getopts("$opts", \%opt) or usage();
usage() if $opt{h};

#
# ServerTech CDU/PDU default creds are 'admn' and 'admn'
# We first try to read the credentials from two env vars:
# $PDU_USER and $PDU_PASS
#
# If the -U or -P flags were specified, we then use the
# values provided with them.
#
my $pdu_user = $ENV{'PDU_USER'} || 'admn';
my $pdu_pass = $ENV{'PDU_PASS'} || 'admn';
$pdu_user = $opt{U} if $opt{U};
$pdu_pass = $opt{P} if $opt{P};

#
# The FTP server paramters we program into each PDU
# Define a default, and then use -u if specified.
#
# NOTE: as of firmware 7.1c and 8.0k, only FTP is supported
# on ServerTech PDUs as a firmware fetching protocol. One day we might
# get http/https as an option, hence the URI format.
#
my $url = 'ftp://ftp:pdu-update@10.66.128.19/pdu/sentry';
$url = $opt{u} if $opt{u};

my $fw_url = URI->new($url);

if ($fw_url->scheme() ne "ftp") {
	die "Currently only ftp:// URLs are supported!";
}

my $ftp_userinfo = $fw_url->userinfo();

my $ftp_user = $1 if $ftp_userinfo =~ /(.*):.*/;
my $ftp_pass = $1 if $ftp_userinfo =~ /.*:(.*)/;
my $ftp_server = $fw_url->host();
my $ftp_path = $fw_url->path();

# We expect to operate on at least one IP/hostname
my @pdus;
if (@ARGV) {
	@pdus = @ARGV;
} else {
	usage();
}

my $ip_validator = Data::Validate::IP->new;

#
# Iterate over each IP address given on the command line
#
foreach my $pdu_ip (@pdus) {

	my %pdu_info;
	my $ver_file;
	my $cmd_file;
	my @output;

	my $restart_needed = undef;

	# Resolve hostnames to IPs, and mke sure we get a valid IP.
	unless ( $ip_validator->is_ipv4($pdu_ip) ) {
		my $packed_ip = inet_aton($pdu_ip)
			or die "could not resolve " . $pdu_ip;
		$pdu_ip = inet_ntoa($packed_ip);
	}

	print "Connecting to " . $pdu_ip . "...\n";

	# In order to talk to ServerTech PDUs, we need to enable some crypto
	# options which OpenSSH has removed from its default set (read: they're
	# bad crypto) so we initiate the OpenSSH object with options to enable
	# them, as well as quiet the Host Key checking. We then initialize a
	# Net::Telnet object and wire that over the OpenSSH pty to issue
	# commands to the PDU's CLI.
	my $ssh = Net::OpenSSH->new($pdu_ip, (
		master_opts => [
			-o => 'KexAlgorithms=+diffie-hellman-group1-sha1',
			-o => 'HostKeyAlgorithms=+ssh-dss',
			-o => 'Ciphers=+aes256-cbc',
			-o => 'LogLevel=QUIET',
			-o => 'StrictHostKeyChecking=no'
			],
		user => $pdu_user,
		password => $pdu_pass
	));

	my ($pty, $pid) = $ssh->open2pty({stderr_to_stdout => 1})
		or die "unable to start remote shell: " . $ssh->error;

	my $telnet = Net::Telnet->new(
		Fhopen => $pty,
		# Dump_Log => '/tmp/dumplog',
		Telnetmode => 0,
		Cmd_remove_mode => 1,
		Timeout => 10,
		Errmode => 'die',
		Prompt  => '/Switched [CP]DU: /'
	);

	$telnet->waitfor($telnet->prompt);
	@output = $telnet->cmd('set option more disabled')
		or die "command failed: set option more disabled";

	# Figure out what kind of ServerTech PDU model we are.
	# PRO1/PRO2 and non-PRO PDU/CDUs are referred to differently:
	# PRO1/PRO2 PDU = "PDU"
	# Switched CDU = "CDU" (Cabinet Distribution Unit)
	# We use this info to then set which firmware version file to check
	# as well as which command file we may need to run, if asked to.
	@output = $telnet->cmd('show system')
		or die "command failed: show system";

	foreach (@output) {
		if (/.*\S:\s+Sentry Switched (PDU|CDU) Version (.*)/) {
			my $type = $1;
			$pdu_info{fw_ver} = $2;

			if ($type eq 'PDU') {
				$pdu_info{type} = "pro";
				$ver_file = 'current-pro.txt';
				$cmd_file = 'cmds-pro.txt';
			} elsif ($type eq 'CDU')  {
				$pdu_info{type} = "swcdu";
				$ver_file = 'current-swcdu.txt';
				$cmd_file = 'cmds-swcdu.txt';
			} else {
				die "FATAL: Could not determine PDU type!";
			}
		}
	}

	print "$pdu_ip is of type " . uc($pdu_info{type}) . ", firmware " .
		$pdu_info{fw_ver} . "\n";

	# Connect to the firmware FTP server and GET either of
	# current-swcdu.txt or current-pro.txt, and look at their
	# contents to know what the current desired firmware version is
	# for PRO or non-PRO PDUs. We use this info to see if we need to
	# upgrade and, if so, to retrieve the desired firmware image.
	my $ftp = Net::FTP->new($ftp_server)
		or die "FTP cannot connect: $@";

	$ftp->login($ftp_user, $ftp_pass)
		or die "FTP login failed: $@";
	$ftp->passive(1)
		or die "FTP set passive failed: $@";
	$ftp->cwd($ftp_path)
		or die "FTP chdir failed: $@";

	# Create a temp file to store our retrieved version file
	my $tmp = File::Temp->new(
		TEMPLATE => 'tmpXXXXX',
		DIR => '/tmp');

	# Save the retrieved version file to the File::Tmp file and quit.
	$ftp->get($ver_file, $tmp->filename)
		or die "FTP could not fetch " . $ver_file . ": $@";
	$ftp->quit;

	# Read the tmp file contents, store the version as a variable.
	# and then delete the Tmp::File.
	my $wanted_ver = slurp($tmp->filename);
	chomp($wanted_ver);
	$tmp->DESTROY;

	# Run any commands from command files if -c was specified. If the
	# expected command file does not, this will die(). On ServerTech
	# PDUs, it is sometimes required to restart the unit in order for
	# a command to take (enabling/disabling things, etc). Generally,
	# it will tell you after the command is ran if that is needed.
	# We will look for 'Restart required to apply changes' and restart
	# the PDU later if we observe that, even if there's no firmware update
	# required.
	if ($opt{c}) {
		print "  Running commands in " . $cmd_file . "...\n";
		my @cmds = split($/, slurp($cmd_file));

		foreach my $cmd (@cmds) {
			print "  Running: " . $cmd . "\n";
			@output = $telnet->cmd($cmd);

			print "  Output:\n";
			foreach my $line (@output) {
				chomp($line);
				$restart_needed = 1 if $line =~ /Restart required to apply changes/;
				$line =~ s/\s+$//g; # compact by trimming
				print "    " . $line . "\n";
			}
		}
	}

	# See if we need to upgrade the PDU. Do so if yes. Doing so would
	# initiate a reset of the PDU. Else, report that firmware is up to
	# date, and check if any commands we ran flagged the unit for a
	# restart and do that if needed. Restarting the PDU does NOT cut power!
	if ($pdu_info{fw_ver} ne $wanted_ver) {
		print "PDU FW out of date!\n" .
			"  Has " . $pdu_info{fw_ver} . ", " .
			"Want ". $wanted_ver  . "\n";

		update_fw(\%pdu_info, $wanted_ver, $telnet);
	} else {
		print $pdu_ip . " firmware is up to date: " .
			$pdu_info{fw_ver} . "\n";

		if ($restart_needed) {
			print "Commands were ran which require" .
				" the PDU be restarted. Restarting...\n";
			$telnet->print('restart')
				or die "cmd restart failed";

			# Answer confirm restart yes/no prompt
			# We need to pause for 2 seconds after answering
			# because if we close the session too quickly, the
			# restart process will abort.
			$telnet->waitfor('/want to restart\?? \(Y\/es N\/o\): /')
				or die "did not receive restart confirm prompt: " .
					$telnet->lastline;
			$telnet->print('y');
			sleep 2;
		} else {
			print $pdu_ip . " no PDU restart required. Done.\n";
		}
	}

	# Close down and go to the next PDU - or quit if no more.
	$telnet->close;
	waitpid($pid, 0);
}

#
# Helper functions
#

#
# Sets up PDU with firmware FTP settings and initiates PDU restart in order
# to download and apply the new firmware.
#
sub update_fw {
	my $pinfo = shift;
	my $fw_ver = shift;
	my $telnet = shift;

	my %pdu_info = %$pinfo;

	# Derive the firmware filename we want based on whether we are
	# a PRO or non-PRO PDU, and deired firmware version string (with
	# no dots).
	$fw_ver =~ s/\.//;

	my $fw_file;
	if ($pdu_info{type} eq "swcdu") {
		$fw_file = "swcdu-v" . $fw_ver . ".bin";
	} elsif ($pdu_info{type} eq "pro") {
		$fw_file = "pro-v" . $fw_ver . ".bin";
	}

	# Set up our ftp parameters in order to fetch the firmware
	print "  Setting FTP parameters in PDU...\n";

	$telnet->print('set ftp host ' . $ftp_server) 
		or die "cmd set ftp host failed";
	$telnet->print('set ftp username ' . $ftp_user) 
		or die "cmd set ftp username failed";
	$telnet->print('set ftp password ' . $ftp_pass) 
		or die "cmd set ftp password failed";
	$telnet->print('set ftp directory ' . $ftp_path) 
		or die "cmd set ftp directory failed";
	$telnet->print('set ftp filename ' . $fw_file) 
		or die "cmd set ftp filename failed";


	# Initiate firmware update with 'restart ftpload'
	print "  Restarting PDU to load new firmware...\n";
	$telnet->print('restart ftpload')
		or die "cmd restart ftpload failed";

	# Answer confirm restart yes/no prompt
	# We need to pause for 2 seconds after answering because if we
	# close the session too quickly, the restart process will abort.
	$telnet->waitfor('/want to restart\?? \(Y\/es N\/o\): /')
		or die "did not receive restart confirm prompt: " .
			$telnet->lastline;
	$telnet->print('y');
	sleep 2;
}

#
# Open a file an slurp its contents into a variable
#
sub slurp {
	my $file = shift;

	open my $fh, '<', $file
		or die "Could not open $file: $@";
	local $/ = undef;
	my $content = <$fh>;
	close $fh;

	return $content;
}

#
# Usage info
#
sub usage {
	print STDERR << "EOF";
Usage: $0 [-hc] [-u url] [-U user] [-P password] pdu_ip ...

	-h	This help output
	-c	Program the PDU with the contents of cmds-pro.txt or
		  cmds-swcdu.txt (done regardless of firmware status)
	-u	PDU firmware in URL format (ftp://user:pass\@host/path/)
	-U	PDU user (or \$PDU_USER env var) Default: admn
	-P	PDU password (or \$PDU_PASS env var) Default: admn
EOF
	exit;
}
